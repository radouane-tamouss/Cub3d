void	init_data(t_game game)
{
	get_data()->mlx = mlx_init();
	if (get_data()->mlx != NULL)
		get_data()->win = mlx_new_window(get_data()->mlx, WIN_WIDTH, WIN_HEIGHT, "cube3d");
	if (get_data()->mlx == NULL || get_data()->win == NULL)
	{
		print_err("CUB3D: mlx failed\n");
		exiter(1);
	}
	get_data()->background_img.img = mlx_new_image(get_data()->mlx, WIN_WIDTH, WIN_HEIGHT);// TODO protect failing
	get_data()->background_img.addr = mlx_get_data_addr(get_data()->background_img.img,
		&(get_data()->background_img.bits_per_pixel), &(get_data()->background_img.line_length),
		&(get_data()->background_img.endian)); // TODO protect failing

	get_data()->floor_color = CREATE_TRGB(0, game.floor.r, game.floor.g, game.floor.b);//BROWN;// TODO this just for startin befroe parsing is complete
	get_data()->ceiling_color = CREATE_TRGB(0, game.ceiling.r, game.ceiling.g, game.ceiling.b);//CYAN;// TODO this just for startin befroe parsing is complete
	// init_background();
	mlx_hook(get_data()->win, 2, 1L << 0, handle_keys, NULL);// this to handle when a key pressed
	mlx_hook(get_data()->win, 3, 1L << 1, key_release, NULL);// this to handle when a key released
	mlx_hook(get_data()->win, 17, 1L << 0, ft_close, NULL);// this to handle when red arrow clicked
	mlx_hook(get_data()->win, 6, 1L<<6, mouse_event, NULL);
    get_data()->speed = 7;
	get_data()->player_pos.x = game.player.pos_x * GRID_DIST + GRID_DIST/2;//1. * GRID_DIST;// TODO for test only
	get_data()->player_pos.y =  game.player.pos_y * GRID_DIST + GRID_DIST/2;//1. * GRID_DIST;// TODO for test only
	get_data()->player_angle = 0;//MY_PI / 4;
	get_data()->player_dir.x = cos(get_data()->player_angle) * get_data()->speed;
	get_data()->player_dir.y = sin(get_data()->player_angle) * get_data()->speed;

	get_data()->map = game.map.grid;
	get_data()->height = game.map.height;
	get_data()->width = game.map.width;

    get_data()->move_forward = 0;
    get_data()->move_backward = 0;
    get_data()->move_left = 0;
    get_data()->move_right = 0;
    get_data()->rotate_left = 0;
    get_data()->rotate_right = 0;
    get_data()->show_scope = 0;
    get_data()->gun_id = 0;
    get_data()->show_tab = 0;

	get_data()->north_img.img_data.img = mlx_xpm_file_to_image(get_data()->mlx, "textures/future_wall.xpm", &(get_data()->north_img.width), &(get_data()->north_img.height));
	get_data()->north_img.img_data.addr = mlx_get_data_addr(get_data()->north_img.img_data.img, &(get_data()->north_img.img_data.bits_per_pixel), &(get_data()->north_img.img_data.line_length), &(get_data()->north_img.img_data.endian));

	get_data()->south_img.img_data.img = mlx_xpm_file_to_image(get_data()->mlx, "textures/future_wall.xpm", &(get_data()->south_img.width), &(get_data()->south_img.height));
	get_data()->south_img.img_data.addr = mlx_get_data_addr(get_data()->south_img.img_data.img, &(get_data()->south_img.img_data.bits_per_pixel), &(get_data()->south_img.img_data.line_length), &(get_data()->south_img.img_data.endian));

	get_data()->east_img.img_data.img = mlx_xpm_file_to_image(get_data()->mlx, "textures/future_wall.xpm", &(get_data()->east_img.width), &(get_data()->east_img.height));
	get_data()->east_img.img_data.addr = mlx_get_data_addr(get_data()->east_img.img_data.img, &(get_data()->east_img.img_data.bits_per_pixel), &(get_data()->east_img.img_data.line_length), &(get_data()->east_img.img_data.endian));
	
	get_data()->west_img.img_data.img = mlx_xpm_file_to_image(get_data()->mlx, "textures/west.xpm", &(get_data()->west_img.width), &(get_data()->west_img.height));
	get_data()->west_img.img_data.addr = mlx_get_data_addr(get_data()->west_img.img_data.img, &(get_data()->west_img.img_data.bits_per_pixel), &(get_data()->west_img.img_data.line_length), &(get_data()->west_img.img_data.endian));
	//===
	get_data()->door_img.img_data.img = mlx_xpm_file_to_image(get_data()->mlx, "textures/1door.xpm", &(get_data()->door_img.width), &(get_data()->door_img.height));
	get_data()->door_img.img_data.addr = mlx_get_data_addr(get_data()->door_img.img_data.img, &(get_data()->door_img.img_data.bits_per_pixel), &(get_data()->door_img.img_data.line_length), &(get_data()->door_img.img_data.endian));
}
void update_door_animation(void)
{
    if (get_data()->door.is_closed)
    {
        int map_x = get_data()->front_ray.map_x;
	    int map_y = get_data()->front_ray.map_y;
	    char *current_tile = &get_data()->map[map_y][map_x];
	
	    if (*current_tile == 'O')
	        *current_tile = 'D';
        get_data()->is_updated = 1;
    }
    if (get_data()->door.is_opening)
    {
        if (get_data()->door.frame_delay++ >= 0)  // Adjust delay value as needed
        {
            get_data()->door.frame_delay = 0;
            get_data()->door.current_frame++;
            
            if (get_data()->door.current_frame >= 40)
            {
                get_data()->door.current_frame = 38;  // Keep at last frame
                get_data()->door.is_opening = 0;
                get_data()->door.is_open = 1;
            }
            
            // Update the door texture
            get_data()->door_img.img_data.img = get_data()->door.img[get_data()->door.current_frame];
            get_data()->door_img.img_data.addr = mlx_get_data_addr(
                get_data()->door_img.img_data.img,
                &get_data()->door_img.img_data.bits_per_pixel,
                &get_data()->door_img.img_data.line_length,
                &get_data()->door_img.img_data.endian
            );
            get_data()->is_updated = 1;
        }
    }
    else if (get_data()->door.is_closing)
    {
        if (get_data()->door.frame_delay++ > 1)  // Adjust delay value as needed
        {
            get_data()->door.frame_delay = 0;
            get_data()->door.current_frame--;
            
            if (get_data()->door.current_frame <= 0)
            {
                get_data()->door.current_frame = 2;  // Keep at first frame
                get_data()->door.is_closing = 0;
                get_data()->door.is_open = 0;
                get_data()->door.is_closed = 1;
            }
            
            // Update the door texture
            get_data()->door_img.img_data.img = get_data()->door.img[get_data()->door.current_frame];
            get_data()->door_img.img_data.addr = mlx_get_data_addr(
                get_data()->door_img.img_data.img,
                &get_data()->door_img.img_data.bits_per_pixel,
                &get_data()->door_img.img_data.line_length,
                &get_data()->door_img.img_data.endian
            );
            get_data()->is_updated = 1;
        }
    }
}

int loop_hook(t_game *game)
{
    if (get_data()->is_tab_pressed)
    {
        render_tab();
        return (0);
    }
	if (get_data()->is_updated)
	{
        update_movement();
		init_background();
		render_walls();
        // render_scope();
		render_minimap();
		render_background();
        update_door_animation();
        // mlx_mouse_hide();
        if (!get_data()->show_scope)
		        render_gun();
            // render_gun_with_transparency();
        // render_scope();
    	// if (get_data()->front_ray.object_hitted == 2 && 
        // 	get_data()->front_ray.dist < 2 * GRID_DIST)
        // {
        //     int text_width = 200;
        //     int text_height = 20;
        //     int text_x = (WIN_WIDTH - text_width) / 2;
        //     int text_y = WIN_HEIGHT - text_height - 10;

        //     // Draw white text
        //     mlx_string_put(get_data()->mlx, get_data()->win, text_x + 10, text_y + 5, 0xFFFFFF, "[Press E to close the door]");
        // }
        // if (get_data()->front_ray.object_hitted == 1 && get_data()->front_ray.dist < 2 * GRID_DIST)
        // {
        //     int text_width = 200;
        //     int text_height = 20;
        //     int text_x = (WIN_WIDTH - text_width) / 2;
        //     int text_y = WIN_HEIGHT - text_height - 10;

        //     // Draw white text
        //     mlx_string_put(get_data()->mlx, get_data()->win, text_x + 10, text_y + 5, 0xFFFFFF, "[Press E to open the door]");
        // }
        // if (get_data()->gun.shooted == 0 && !player_is_close_to_door())
        // {
        //     int text_x = (WIN_WIDTH - 200) / 2;
        //     int text_y = WIN_HEIGHT - 20 - 10;
        //     // Draw white text
        //     mlx_string_put(get_data()->mlx, get_data()->win, text_x + 10, text_y + 5, 0xFFFFFF, "[Press T to reload the gun]");
        // }

	}
    return (0);
}

int main(int ac, char **av)
{
    int fd;
    t_game game;

    if (ac != 2 || check_file(av[1], &fd) == 0)
        return (printf("Error\nUsage: ./Cube3d map.cub\n"), 0);
    game = check_map(fd, av[1]);
    close(fd);
	init_data(game);
	init_background();
	render_walls();
	render_background();
	load_frames();
    load_first_gun_frames();
    load_shooting_gun2_frames();
    load_running_gun2_frames();
    load_walking_gun2_frames();
    load_door_frames();
	mlx_loop_hook(get_data()->mlx, loop_hook, NULL);

    mlx_loop(get_data()->mlx);

    return (0);
}
typedef struct s_door {
    void    *img[43];       // Array to store door frame images
    int     width;          // Width of door image
    int     height;         // Height of door image
    int     current_frame;  // Current frame being displayed
    int     frame_delay;    // Delay counter for animation
    int     is_opening;     // Flag for opening animation
    int     is_open;        // Flag to indicate if door is fully open
    int     is_closing;     // Flag for closing animation
    int    is_closed;      // Flag to indicate if door is fully closed
} t_door;
typedef struct s_map
{
    char **grid;
    int width;
    int height;
    int valid;
} t_map;

typedef struct s_data
{
	void		*mlx;
	void		*win;
	// t_img_data	walls;
    int move_forward;
    int move_backward;
    int move_left;
    int move_right;
    int rotate_left;
    int rotate_right;
    int show_scope;
    int is_tab_pressed;
	t_texture	north_img;
	t_texture	south_img;
	t_texture	east_img;
    int speed;
	t_texture	west_img;
	t_texture	door_img;

    t_img_data scope; 
	t_img_data	background_img;
	int			ceiling_color;
	int			floor_color;
	char		**map;
	int			height;
	int			width;
	float		player_angle;//
    int player_is_moving;
	t_vector	player_pos;
    int is_control_pressed;
	t_vector	player_dir;
	t_vector	mouse_pos;
	t_texture	minimap;
    int is_walking;
    int is_running;
	int			is_updated;
	int			dark_mode;
	t_ray_data		front_ray;
    t_gun          gun;
    t_gun         gun2;
    int show_tab;
    int gun_id;
    t_door          door;

} t_data;

//=================================
t_data	*get_data(void);

int	handle_keys(int keycode, void *garbage)
{
	(void)garbage;
	// printf("keycode => %d\n", keycode);
	if (keycode == ESC)
	{
		// fprintf(stderr , "==========heeeereeeeee\n");//
		mlx_destroy_window(get_data()->mlx, get_data()->win);

		exiter(0);
	}
    if (keycode == CNTRL_LIN)
    {
        get_data()->is_control_pressed = 1;
        get_data()->show_tab = 1;
    }
	// else if (keycode == W_LIN)
	// 	move_forward();
	// else if (keycode == S_LIN)
	// 	move_backward();
	// else if (keycode == D_LIN)
	// 	move_right();
	// else if (keycode == A_LIN)
	// 	move_left();
    if (keycode == W_LIN || keycode == S_LIN || keycode == D_LIN || keycode == A_LIN)
    {
        if (get_data()->speed >= 10)
        {
            get_data()->is_running = 1;
            get_data()->is_walking = 0;
        }
        else
        {
            get_data()->is_running = 0;
            get_data()->is_walking = 1;
        }
    }
    if (keycode == W_LIN)
        get_data()->move_forward = 1;
    else if (keycode == S_LIN)
        get_data()->move_backward = 1;
    else if (keycode == D_LIN)
        get_data()->move_right = 1;
    else if (keycode == A_LIN)
        get_data()->move_left = 1;
	if (keycode == RIGHT_LIN)
		// rotate_player(2.  * (MY_PI / (float)180));
        get_data()->rotate_right = 1;
	else if (keycode == LEFT_LIN)
		// rotate_player(-2.  * (MY_PI / (float)180));
        get_data()->rotate_left = 1;
	else if (keycode == SPACE_LIN)
	{
		if (get_data()->dark_mode == 1)
			get_data()->dark_mode = 0;
		else
			get_data()->dark_mode = 1;
	}
	else if (keycode == E_LIN)
	// {
	//
	    //    if (get_data()->front_ray.dist < 2 * GRID_DIST)
	    //    {
	    //        int map_x = get_data()->front_ray.map_x;
	    //        int map_y = get_data()->front_ray.map_y;
	    //        char *current_tile = &get_data()->map[map_y][map_x];
	
	    //        if (*current_tile == 'D')
	    //            *current_tile = 'O';
	    //        else if (*current_tile == 'O')
	    //            *current_tile = 'D';
	    //    }
	//
	//        get_data()->is_updated = 1;
	// }
  {
    if (get_data()->front_ray.object_hitted == 1 && get_data()->front_ray.dist < 2 * GRID_DIST)
    {
        get_data()->map[get_data()->front_ray.map_y][get_data()->front_ray.map_x] = 'D';
        if (!get_data()->door.is_open && !get_data()->door.is_opening)
        {
            get_data()->door.is_opening = 1;
            get_data()->door.current_frame = 0;
            get_data()->door.frame_delay = 0;
        }
        else if (get_data()->door.is_open && !get_data()->door.is_closing)
        {
            get_data()->door.is_closing = 1;
            get_data()->door.current_frame = 40;
            get_data()->door.frame_delay = 0;
        }
        
      get_data()->is_updated = 1;
    }
}
    else if (keycode == Z_LIN)
    {
        get_data()->show_scope = 1;
    }
	  else  if (keycode == T_LIN)  // Add proper key define if needed
    {
		get_data()->gun.shooted = 1;
        get_data()->gun.is_reloading = 1;
        get_data()->gun.current_frame = 0;
        get_data()->gun.frame_delay = 0;
    }
    else if (keycode == Y_LIN)
    {
        get_data()->gun2.shooted = 1;
        get_data()->gun2.is_reloading = 1;
        get_data()->gun2.current_frame = 0;
        get_data()->gun2.frame_delay = 0;
    }
    else if (keycode == N_LIN)
    {
        printf("n pressed\n");
        get_data()->gun2.is_shooting = 1;
        get_data()->gun2.current_frame = 0;
        get_data()->gun2.frame_delay = 0;
        get_data()->gun2.is_reloading = 0;
        get_data()->is_running = 0;
        get_data()->is_walking = 0;

    }
    else if (keycode == SHIFT_LIN)
    {
        get_data()->speed = 10;
    }
    else if (keycode == TAB_LIN && !get_data()->is_tab_pressed)
    {
        // get_data()->gun_id++;
        // if (get_data()->gun_id >= 2)
        //     get_data()->gun_id = 0;
        
        get_data()->show_tab = 1;
        get_data()->is_tab_pressed = 1;
    }
	get_data()->is_updated = 1;
	return (0);
}

int key_release(int keycode, void *garbage)
{
    (void)garbage;
    if (keycode == CNTRL_LIN)
    {
        get_data()->is_control_pressed = 0;
    }
    if (keycode == W_LIN)
        get_data()->move_forward = 0;
    else if (keycode == S_LIN)
        get_data()->move_backward = 0;
    else if (keycode == D_LIN)
        get_data()->move_right = 0;
    else if (keycode == A_LIN)
        get_data()->move_left = 0;
    if (keycode == RIGHT_LIN)
        get_data()->rotate_right = 0;
    else if (keycode == LEFT_LIN)
        get_data()->rotate_left = 0;
    else if (keycode == Z_LIN)
        get_data()->show_scope = 0;
    else if (keycode == TAB_LIN)
    {
        get_data()->is_tab_pressed = 0;
        get_data()->show_tab = 0;
    }
    else if (keycode == SHIFT_LIN)
        get_data()->speed = 8;
    if (keycode == W_MAC || keycode == S_MAC || keycode == D_MAC || keycode == A_MAC)
    {
        if (get_data()->move_backward == 0 && get_data()->move_forward == 0 && get_data()->move_left == 0 && get_data()->move_right == 0)
        {
            get_data()->is_running = 0;
            get_data()->is_walking = 0;
            get_data()->gun2.current_frame = 0;
            get_data()->gun2.frame_delay = 0;
        }
    }
    return (0);
}